---
title: "android_guide"
date: 2016-02-12 16:49
---
#Android Guide
##Introduction
###System Permissions
+ checking permissions,``Context.checkCallingPermission()``,``Context.checkPermission(String, int, int)``,``PackageManager.checkPermission(String, String)``
+ per-uri permission,when starting an activity or returning a result to an activity, the caller can set ``Intent.FLAG_GRANT_READ_URI_PERMISSION`` and/or ``Intent.FLAG_GRANT_WRITE_URI_PERMISSION``. This grants the receiving activity permission access the specific data URI in the Intent, regardless of whether it has any permission to access data in the content provider corresponding to the Intent.The granting of fine-grained URI permissions does, however, require some cooperation with the content provider holding those URIs. It is strongly recommended that content providers implement this facility, and declare that they support it through the ``android:grantUriPermissions`` attribute or ``<grant-uri-permissions>`` tag.在发送携带数据uri的Intent时，设置``Intent.FLAG_GRANT_READ_URI_PERMISSION``或者``Intent.FLAG_GRANT_WRITE_URI_PERMISSION``可以给接收Intent的activity赋予读取，写入数据的权利。per-uri permission需要content provider的协助。
+ To add a fragment without a UI, add the fragment from the activity using ``add(Fragment, String)`` (supplying a unique string "tag" for the fragment, rather than a view ID). This adds the fragment, but, because it's not associated with a view in the activity layout, it does not receive a call to ``onCreateView()``. So you don't need to implement that method.通过``add(fragment, String)``来为``fragment``设置一个``tag``方便未来``findFragmentByTag``来进行查找。Supplying a string tag for the fragment isn't strictly for non-UI fragments—you can also supply string tags to fragments that do have a UI—but if the fragment does not have a UI, then the string tag is the only way to identify it. If you want to get the fragment from the activity later, you need to use ``findFragmentByTag()``.
+ Calling ``commit()`` does not perform the transaction immediately. Rather, it schedules it to run on the activity's UI thread (the "main" thread) as soon as the thread is able to do so. If necessary, however, you may call ``executePendingTransactions()`` from your UI thread to immediately execute transactions submitted by ``commit()``. Doing so is usually not necessary unless the transaction is a dependency for jobs in other threads.调用``FragmentTransaction.commit``并不马上执行``transaction``中的动作，而是将其放入主线程消息队列中等待调度。可以调用``FragmentTransaction.executePendingTransactions``来马上执行commit的transaction。
+ Fragment与Activity进行通信，``getActivity``，Fragment与Fragment进行通信，在FragmentA中建立一个interface，Activity实现interface，在FragmentA中``onActivityCreate``回调方法中将activity强转为interface。``setArguments``,``setTargetFragment``。
+ launchmode,``standard``,``singleTop``If an instance of the activity already exists at the top of the current task, the system routes the intent to that instance through a call to its ``onNewIntent()`` method, rather than creating a new instance of the activity. The activity can be instantiated multiple times, each instance can belong to different tasks, and one task can have multiple instances (but only if the activity at the top of the back stack is not an existing instance of the activity).如果实例已经在task的顶部，则回调实例的``onNewIntent``方法而不是重新创建一个实例。实例可以创建多次，从属于不同的task。``singleTask``The system creates a new task and instantiates the activity at the root of the new task. However, if an instance of the activity already exists in a separate task, the system routes the intent to the existing instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance of the activity can exist at a time.如果没有实例不存在，则创建一个实例作为一个新的task的root，如果实例已经存在于其他的task中，则cleartop并回调实例的``onNewIntent``方法。``singleInstance``Same as "singleTask", except that the system doesn't launch any other activities into the task holding the instance. The activity is always the single and only member of its task; any activities started by this one open in a separate task.``singleInstance``模式下实例只能存在于一个task中，task不能有其他组件。``taskAffinity``task别名，一般为包名。
+ task root activity,``alwaysRetainTaskState``,``clearTaskOnLaunch``针对整个task,``finishOnTaskLaunch``针对单一activity
+ 同一activity的不同实例显示在recent task list中，像chrome的标签页一样，``startActivity``中``Intent``设置``FLAG_ACTIVITY_NEW_DOCUMENT``,``FLAG_ACTIVITY_MULTIPLE_TASK``.``android:documentLaunchMode``,``intoExisting``,``always``,``never``,``none``.set ``android:excludeFromRecents`` to true can always exclude a task from the overview screen entirely by setting the ``<activity>`` attribute.
+ ContentProvider,DAO,UriMatcher处理不同表，权限，读写，读，写，表级别限制
+ Process Level
  + Foreground process
  + Visible process
  + Service process
  + Background process
  + Empty process
+ 尽管视图组通常不会画自身的内容,但是在很多情况下还是有这个需求的,有两个地方,我们可以要求ViewGroup画一些内容,一个是在dispatchDraw()里,父类的方法调用之后,此时,由于孩子视图已经绘制完毕,因此我们所画的东西就会在其之上,第二个地方是ViewGroup的onDraw()回调,正如之前我们在View里见到的onDraw一样,我们在这儿画的东西会赶在孩子视图绘制之前,所以这里的内容是在孩子视图内容之下的,这里适合画各种,动态的背景或者是一些状态选择器,如果你要在ViewGroup的onDraw里面添代码,你不能忘记使ViewGroup的onDraw回调有效,调用setWillNotDraw(false),否则,你的onDraw()方法不能被触发,因为ViewGroup自身onDraw方法默认是禁用的.