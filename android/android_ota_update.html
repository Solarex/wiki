<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="../static/css/typo.css">
        <link rel="Stylesheet" type="text/css" href="../static/css/reset_typo.css">
        <link rel="Stylesheet" type="text/css" href="../static/css/tango.css">
        <link rel="Stylesheet" type="text/css" href="../static/css/style.css">
        <title>Android OTA Update - Wiki·Solarex</title>
        <meta name="keywords" content="android,linux,python,mac"/>
        <meta name="description" content="Solarex's personal wiki,powered by simiki.Focus on Android, Python, Linux, Mac and so on."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
<script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.js"></script>
<script language="javascript" type="text/javascript">
    var oddClick = true;
    $(document).ready(function() {
      $('#toggle-button').click(function() {
        $('#container').animate({
          width: oddClick? "100%":"60%",
        });
        $(this).text(oddClick? "窄版":"宽版");
        oddClick = !oddClick;
      });
    });
</script>

    </head>

    <body>
        <a href="https://github.com/Solarex/wiki"><img style="position: fixed; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
        <div id="container">
            
    <div id="header">
        <div id="post-nav">
            <div id="toggle-button">宽版</div>
            
            <a href="https://solarex.github.io/wiki/">Home</a> » <a href="https://solarex.github.io/wiki/#Android">Android</a> » Android OTA Update
            
        </div>
    </div>
    <div class="clearfix"></div>
    <h1><center>Android OTA Update</center></h1>
    <hr>
    <div id="content">
        <h3 id="android-ota-update">Android OTA Update</h3>
<ul>
<li>
<p><a href="https://source.android.com/devices/tech/ota/index.html">ref</a></p>
</li>
<li>
<p>Devices have a special recovery partition with the software needed to unpack a downloaded update package and apply it to the rest of the system.</p>
</li>
<li>OTA updates are designed to upgrade the underlying operating system and the read-only apps installed on the system partition; these updates do not affect applications installed by the user from Google Play.</li>
<li>The flash space on an Android device typically contains the following partitions.</li>
<li><code>boot</code>,Contains the Linux kernel and a minimal root filesystem (loaded into a RAM disk). It mounts system and other partitions and starts the runtime located on the system partition.</li>
<li><code>system</code>,Contains system applications and libraries that have source code available on Android Open Source Project (AOSP). During normal operation, this partition is mounted read-only; its contents change only during an OTA update.</li>
<li><code>vendor</code>,Contains system applications and libraries that do not have source code available on Android Open Source Project (AOSP). During normal operation, this partition is mounted read-only; its contents change only during an OTA update.</li>
<li><code>userdata</code>,Stores the data saved by applications installed by the user, etc. This partition is not normally touched by the OTA update process.</li>
<li><code>cache</code>,Temporary holding area used by a few applications (accessing this partition requires special app permissions) and for storage of downloaded OTA update packages. Other programs use this space with the expectation that files can disappear at any time. Some OTA package installations may result in this partition being wiped completely.</li>
<li><code>recovery</code>,Contains a second complete Linux system, including a kernel and the special recovery binary that reads a package and uses its contents to update the other partitions.</li>
<li>
<p><code>misc</code>,Tiny partition used by recovery to stash some information away about what it's doing in case the device is restarted while the OTA package is being applied.</p>
</li>
<li>
<p>Life of an OTA update</p>
</li>
<li>Device performs regular check in with OTA servers and is notified of the availability of an update, including the URL of the update package and a description string to show the user.</li>
<li>Update downloads to a cache or data partition, and its cryptographic signature is verified against the certificates in <code>/system/etc/security/otacerts.zip</code>. User is prompted to install the update.</li>
<li>Device reboots into <strong>recovery mode</strong>, in which the kernel and system in the recovery partition are booted instead of the kernel in the boot partition.</li>
<li>Recovery binary is started by <code>init</code>. It finds command-line arguments in <code>/cache/recovery/command</code> that point it to the downloaded package.</li>
<li>Recovery verifies the cryptographic signature of the package against the public keys in <code>/res/keys</code> (part of the RAM disk contained in the recovery partition).</li>
<li>Data is pulled from the package and used to update the <code>boot</code>, <code>system</code>, and/or <code>vendor</code> partitions as necessary. One of the new files left on the <code>system</code> partition contains the contents of the new recovery partition.</li>
<li>
<p>Device reboots normally.(a)The newly updated boot partition is loaded, and it mounts and starts executing binaries in the newly updated system partition.(b)As part of normal startup, the system checks the contents of the recovery partition against the desired contents (which were previously stored as a file in /system). They are different, so the recovery partition is reflashed with the desired contents. (On subsequent boots, the recovery partition already contains the new contents, so no reflash is necessary.)</p>
</li>
<li>
<p>The <code>ota_from_target_files</code> tool provided in <code>build/tools/releasetools</code> can build two types of package: <code>full</code> and <code>incremental</code>. The tool takes the <code>target-files</code> <code>.zip</code> file produced by the Android build system as input.</p>
</li>
<li>A full update is one where the entire final state of the device (system, boot, and recovery partitions) is contained in the package. As long as the device is capable of receiving the package and booting the recovery system, the package can install the desired build regardless of the current state of the device.</li>
</ul>
<div class="hlcode"><pre><span class="c"># first, build the target-files .zip</span>
% . build/envsetup.sh <span class="o">&amp;&amp;</span> lunch tardis-eng
% mkdir dist_output
% make dist <span class="nv">DIST_DIR</span><span class="o">=</span>dist_output
  <span class="o">[</span>...<span class="o">]</span>
% ls -l dist_output/*target_files*
-rw-r----- 1 user eng  69965275 Sep 29 15:51 tardis-target_files.zip
<span class="c"># The target-files .zip contains everything needed to construct OTA packages.</span>
% ./build/tools/releasetools/ota_from_target_files <span class="se">\</span>
    dist_output/tardis-target_files.zip ota_update.zip
unzipping target target-files...
<span class="k">done</span>.
% ls -l ota_update.zip
-rw-r----- 1 user eng 62236561 Sep 29 15:58 ota_update.zip
</pre></div>


<ul>
<li>An incremental update contains a set of binary patches to be applied to the data already on the device. This can result in considerably smaller update packages:(a)Files that have not changed don't need to be included.(b)Files that have changed are often very similar to their previous versions, so the package need only contain an encoding of the differences between the two files.You can install the incremental update package only on a device that has the old or source build used when constructing the package. To build an incremental update, you need the target_files .zip from the previous build (the one you want to update from) as well as the target_files .zip from the new build.</li>
</ul>
<div class="hlcode"><pre>% ./build/tools/releasetools/ota_from_target_files <span class="se">\</span>
    -i PREVIOUS-tardis-target_files.zip <span class="se">\ </span> <span class="c"># make incremental from this older version</span>
    dist_output/tardis-target_files.zip incremental_ota_update.zip
unzipping target target-files...
unzipping <span class="nb">source </span>target-files...
   <span class="o">[</span>...<span class="o">]</span>
<span class="k">done</span>.
% ls -l incremental_ota_update.zip
-rw-r----- 1 user eng 1175314 Sep 29 16:10 incremental_ota_update.zip
<span class="c">#To generate a block-based OTA for subsequent updates, pass the --block option to ota_from_target_files.</span>
</pre></div>


<ul>
<li>An update package (<code>ota_update.zip</code>, <code>incremental_ota_update.zip</code>) is a <code>.zip</code> file that contains the executable binary <code>META-INF/com/google/android/update-binary</code>. After verifying the signature on the package, recovery extracts this binary to <code>/tmp</code> and runs it, passing the following arguments:</li>
<li>Update binary API version number. If the arguments passed to the update binary change, this number is incremented.</li>
<li>File descriptor of the command pipe. The update program can use this pipe to send commands back to the recovery binary (mostly for UI changes such as indicating progress to the user).</li>
<li>
<p>Filename of the update package .zip file.
A recovery package can use any statically-linked binary as the update binary. The OTA package construction tools use the updater program (source in bootable/recovery/updater), which provides a simple scripting language that can do many installation tasks. You can substitute any other binary running on the device.</p>
</li>
<li>
<p>Android 5.0 and later versions use <code>block OTA</code> updates to ensure that each device uses the exact same partition. Instead of comparing individual files and computing binary patches, <code>block OTA</code> handles the entire partition as one file and computes a single binary patch, ensuring the resultant partition contains exactly the intended bits. This allows the device system image to achieve the same state via <code>fastboot</code> or OTA.Android 4.4 and earlier versions used <code>file OTA</code> updates, which ensured devices contained similar <code>file contents, permissions, and modes</code>, but allowed metadata such as timestamps and the layout of the underlying storage to vary between devices based on the update method.</p>
</li>
<li>
<p>Because <code>block OTA</code> ensures that each device uses the same partition, it enables the use of <code>dm-verity</code> to cryptographically sign the system partition.</p>
</li>
<li>
<p>During a file-based OTA, Android attempts to change the contents of the system partition at the filesystem layer (on a file-by-file basis). The update is not guaranteed to write files in a consistent order, have a consistent last modified time or superblock, or even place the blocks in the same location on the block device. For this reason, file-based OTAs fail on a dm-verity-enabled device; after the OTA attempt, the device does not boot.During a block-based OTA, Android serves the device the difference between the two block images (rather than two sets of files). The update checks a device build against the corresponding build server at the block level (below the filesystem) using one of the following methods:</p>
</li>
<li><code>Full update</code>. Copying the full system image is simple and makes patch generation easy but also generates large images that can make applying patches expensive.</li>
<li><code>Incremental update</code>. Using a binary differ tool generates smaller images and makes patch application easy, but is memory-intensive when generating the patch itself.</li>
</ul>
<p><code>adb fastboot</code> places the exact same bits on the device as a <code>full OTA</code>, so flashing is compatible with <code>block OTA</code>.</p>
<ul>
<li>In general, <code>incremental block OTA</code> updates are larger than <code>incremental file OTA</code> updates due to:</li>
<li>Data preservation. Block-based OTAs preserve more data (<code>file metadata</code>, <code>dm-verity data</code>, <code>ext4 layout</code>, etc.) than file-based OTA.</li>
<li>Computation algorithm differences. In a <code>file OTA update</code>, if a file path is identical in both builds, the OTA package contains no data for that file. In a <code>block OTA update</code>, determining little or no change in a file depends on the quality of the patch computation algorithm and layout of file data in both source and target system.</li>
</ul>
<p>If a file is corrupted, a file OTA succeeds as long as it doesn't touch the corrupted file, but a block OTA fails if it detects any corruption on the system partition.</p>
<p>The system builds the <strong>updater binary</strong> from <code>bootable/recovery/updater</code> and uses it in an OTA package.The package itself is a <code>.zip</code> file (<code>ota_update.zip</code>, <code>incremental_ota_update.zip</code>) that contains the executable binary <code>META-INF/com/google/android/update-binary</code>.Updater contains several builtin functions and an interpreter for an extensible scripting language (edify) that supports commands for typical update-related tasks. Updater looks in the package .zip file for a script in the file <code>META-INF/com/google/android/updater-script</code>.Using the edify script and/or builtin functions is not a common activity, but can be helpful if you need to debug the update file.</p>
<p>An edify script is a single expression in which all values are strings. Empty strings are <strong>false</strong> in a Boolean context and all other strings are <strong>true</strong>. Edify supports the following operators (with the usual meanings):</p>
<div class="hlcode"><pre><span class="o">(</span>expr <span class="o">)</span>
 expr + expr  <span class="c"># string concatenation, not integer addition</span>
 <span class="nv">expr</span> <span class="o">==</span> expr
 expr !<span class="o">=</span> expr
 expr <span class="o">&amp;&amp;</span> expr
 expr <span class="o">||</span> expr
 ! expr
 <span class="k">if </span>expr <span class="k">then </span>expr endif
 <span class="k">if </span>expr <span class="k">then </span>expr <span class="k">else </span>expr endif
 function_name<span class="o">(</span>expr, expr,...<span class="o">)</span>
 expr; expr
</pre></div>


<ul>
<li>The recovery system includes several hooks for inserting device-specific code so that OTA updates can also update parts of the device other than the Android system (e.g., the baseband or radio processor).The partition map file is specified by <code>TARGET_RECOVERY_FSTAB</code>; this file is used by both the recovery binary and the package-building tools. You can specify the name of the map file in <code>TARGET_RECOVERY_FSTAB</code> in <code>BoardConfig.mk</code>.</li>
</ul>
<p>A sample partition map file might look like this:</p>
<div class="hlcode"><pre>device/yoyodyne/tardis/recovery.fstab
<span class="c"># mount point       fstype  device       [device2]        [options (3.0+ only)]</span>

/sdcard     vfat    /dev/block/mmcblk0p1 /dev/block/mmcblk0
/cache      yaffs2  cache
/misc       mtd misc
/boot       mtd boot
/recovery   emmc    /dev/block/platform/s3c-sdhci.0/by-name/recovery
/system     ext4    /dev/block/platform/s3c-sdhci.0/by-name/system <span class="nv">length</span><span class="o">=</span>-4096
/data       ext4    /dev/block/platform/s3c-sdhci.0/by-name/userdata
</pre></div>


<p>There are five supported filesystem types:<code>yaffs2</code>,<code>mtd</code>,<code>ext4</code>,<code>emmc</code>,<code>vfat</code>.</p>
<p>Starting in Android 3.0, the <code>recovery.fstab</code> file gains an additional optional field, options. Currently the only defined option is length , which lets you explicitly specify the length of the partition. This length is used when reformatting the partition (e.g., for the userdata partition during a data wipe/factory reset operation, or for the system partition during installation of a full OTA package). If the length value is negative, then the size to format is taken by adding the length value to the true partition size. For instance, setting "length=-16384" means the last 16k of that partition will not be overwritten when that partition is reformatted. This supports features such as encryption of the userdata partition (where encryption metadata is stored at the end of the partition that should not be overwritten).</p>
<ul>
<li>
<p>Android OS images use cryptographic signatures in two places:</p>
</li>
<li>
<p>Each <code>.apk</code> file inside the image must be signed. Android's Package Manager uses an <code>.apk</code> signature in two ways:</p>
<ul>
<li>When an application is replaced, it must be signed by the same key as the old application in order to get access to the old application's data. This holds true both for updating user apps by overwriting the <code>.apk</code>, and for overriding a system app with a newer version installed under <code>/data</code>.</li>
<li>If two or more applications want to share a user ID (so they can share data, etc.), they must be signed with the same key.</li>
</ul>
</li>
<li>
<p>OTA update packages must be signed with one of the keys expected by the system or the installation process will reject them.</p>
</li>
<li>
<p>To generate your own unique set of release-keys, run these commands from the root of your Android tree:</p>
</li>
</ul>
<div class="hlcode"><pre><span class="c">#$subject should be changed to reflect your organization&#39;s information.</span>
<span class="nv">subject</span><span class="o">=</span><span class="s1">&#39;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&#39;</span>
mkdir ~/.android-certs
<span class="k">for </span>x in releasekey platform shared media; <span class="k">do</span> <span class="se">\</span>
    ./development/tools/make_key ~/.android-certs/<span class="nv">$x</span> <span class="s2">&quot;$subject&quot;</span>; <span class="se">\</span>
<span class="k">done</span>
</pre></div>


<ul>
<li>To generate a release image, use:</li>
</ul>
<div class="hlcode"><pre>make dist
./build/tools/releasetools/sign_target_files_apks <span class="se">\</span>
    -o <span class="se">\ </span>   <span class="c"># explained in the next section</span>
    -d ~/.android-certs out/dist/*-target_files-*.zip <span class="se">\</span>
    signed-target_files.zip
</pre></div>


<p>The <code>sign_target_files_apks</code> script takes a <code>target-files .zip</code> as input and produces a new <code>target-files .zip</code> in which all the .apks have been signed with new keys. The newly signed images can be found under <code>IMAGES/</code> in <code>signed-target_files.zip</code>.</p>
<ul>
<li>A signed target-files zip can be converted into a signed OTA update zip using the following procedure:</li>
</ul>
<div class="hlcode"><pre>./build/tools/releasetools/ota_from_target_files <span class="se">\</span>
    -k ~/.android-certs/releasekey <span class="se">\</span>
    signed-target_files.zip <span class="se">\</span>
    signed-ota_update.zip
</pre></div>


<ul>
<li>
<p>Update packages received from the main system are typically verified twice: once by the main system, using the <code>RecoverySystem.verifyPackage()</code> method in the android API, and then again by recovery. The RecoverySystem API checks the signature against public keys stored in the main system, in the file <code>/system/etc/security/otacerts.zip</code> (by default). Recovery checks the signature against public keys stored in the recovery partition RAM disk, in the file <code>/res/keys</code>.</p>
</li>
<li>
<p>Each key comes in two files: the <strong>certificate</strong>, which has the extension <strong>.x509.pem</strong>, and the <strong>private key</strong>, which has the extension <strong>.pk8</strong>. The private key should be kept secret and is needed to sign a package. The key may itself be protected by a password. The certificate, in contrast, contains only the public half of the key, so it can be distributed widely. It is used to verify a package has been signed by the corresponding private key.
The standard Android build uses four keys, all of which reside in build/target/product/security:</p>
</li>
<li><code>testkey</code>:Generic default key for packages that do not otherwise specify a key.</li>
<li><code>platform</code>:Test key for packages that are part of the core platform.</li>
<li><code>shared</code>:Test key for things that are shared in the home/contacts process.</li>
<li><code>media</code>:Test key for packages that are part of the media/download system.
Individual packages specify one of these keys by setting <code>LOCAL_CERTIFICATE</code> in their <code>Android.mk</code> file. (testkey is used if this variable is not set.) You can also specify an entirely different key by pathname, e.g.:</li>
</ul>
<div class="hlcode"><pre><span class="c">#device/yoyodyne/apps/SpecialApp/Android.mk</span>
 <span class="o">[</span>...<span class="o">]</span>

LOCAL_CERTIFICATE :<span class="o">=</span> device/yoyodyne/security/special
<span class="c">#Now the build uses the device/yoyodyne/security/special.{x509.pem,pk8} key to sign SpecialApp.apk. The build can use only private keys that are not password protected.</span>
</pre></div>


<ul>
<li>Android uses 2048-bit RSA keys with public exponent 3. You can generate certificate/private key pairs using the openssl tool from openssl.org:</li>
</ul>
<div class="hlcode"><pre><span class="c"># generate RSA key</span>
% openssl genrsa -3 -out temp.pem 2048
Generating RSA private key, 2048 bit long modulus
....+++
.....................+++
e is 3 <span class="o">(</span>0x3<span class="o">)</span>

<span class="c"># create a certificate with the public part of the key</span>
% openssl req -new -x509 -key temp.pem -out releasekey.x509.pem <span class="se">\</span>
  -days 10000 <span class="se">\</span>
  -subj <span class="s1">&#39;/C=US/ST=California/L=San Narciso/O=Yoyodyne, Inc./OU=Yoyodyne Mobility/CN=Yoyodyne/emailAddress=yoyodyne@example.com&#39;</span>

<span class="c"># create a PKCS#8-formatted version of the private key</span>
% openssl pkcs8 -in temp.pem -topk8 -outform DER -out releasekey.pk8 -nocrypt

<span class="c"># securely delete the temp.pem file</span>
% shred --remove temp.pem
</pre></div>


<p>The openssl pkcs8 command given above creates a <code>.pk8</code> file with no password, suitable for use with the build system. To create a <code>.pk8</code> secured with a password (which you should do for all actual release keys), replace the <code>-nocrypt</code> argument with <code>-passout stdin</code>; then openssl will encrypt the private key with a password read from standard input.</p>
<ul>
<li>Once you have signed-target-files.zip, you need to create the image so you can put it onto a device. To create the signed image from the target files, run the following command from the root of the Android tree:</li>
</ul>
<div class="hlcode"><pre>./build/tools/releasetools/img_from_target_files signed-target-files.zip signed-img.zip
</pre></div>


<p>The resulting file, <code>signed-img.zip</code>, contains all the <code>.img</code> files. To load an image onto a device, use fastboot as follows:<code>fastboot update signed-img.zip</code>.</p>
    </div>

        </div>
        <div id="footer">
              <p>
                Copyright © 2012-2017 Solarex.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
              </p>
                <p>Last Update 2017-03-26 05:30:21</p>
        </div>
    </body>
</html>