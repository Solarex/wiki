<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="../static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="../static/css/tango.css">
        <title>Sticky Notes - Wiki.Solarex</title>
        <meta name="keywords" content="wiki, markdown, linux, python, git, vim and so on"/>
        <meta name="description" content="Solarex's wiki, powered by simiki, focus on linux, python and other stuff"/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <a href="https://github.com/Solarex/wiki"><img style="position: fixed; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
                <div id="container">
            
    <div id="header">
        <div id="post-nav">
            
            <a href="https://solarex.github.io/wiki">Home</a> » <a href="https://solarex.github.io/wiki#android">android</a> » Sticky Notes
            
        </div>
    </div>
    <div class="clearfix"></div>
    <div id="title">Sticky Notes</div>
    <div id="content">
        <ul>
<li>Activity <code>getIntent()</code> Return the intent that started this activity.</li>
<li>PackageManager <code>queryIntentActivities(Intent intent, int flags)</code> Retrieve all activities that can be performed for the given intent. 取得所有可以对给定intent响应的activity。</li>
<li>ResolveInfo <code>loadLabel(PackageManager pm)</code> Retrieve the current textual label associated with this resolution.</li>
<li><code>ApplicationInfo</code> Information you can retrieve about a particular application. This corresponds to information collected from the <code>AndroidManifest.xml's &lt;application&gt;</code> tag.<code>ApplicationInfo</code> 所有可以从特定应用中取得的信息，和从<code>AndroidManifest.xml</code>文件<code>&lt;application&gt;</code>节点中搜集来的信息一一对应。</li>
<li><code>PackageInfo</code> Overall information about the contents of a package. This corresponds to all of the information collected from <code>AndroidManifest.xml</code>.关于package的所有信息，和在<code>AndroidManifest.xml</code>中搜集来的信息对应。</li>
<li><code>android:sharedUserLabel</code> A user-readable label for the shared user ID. The label must be set as a reference to a string resource; it cannot be a raw string.This attribute was introduced in API Level 3. It is meaningful only if the sharedUserId attribute is also set. <code>AndroidManifest.xml</code>中<code>&lt;manifest&gt;</code> tag中的<code>android:sharedUserLabel</code>是一个对用户可读的表示<code>sharedUserId</code>的字符串，必须设置为一个string资源的引用，不能是raw string。只有在<code>android:sharedUserId</code>也被设置的时候才有意义。</li>
<li>Prior to Android 2.0, devices have seen a lot of services hanging around and claiming resources even though there was no work to be done, meaning Android brought the services back into memory even though there were no messages in the queue. This would have happened when <code>stopService</code> was not invoked either because of an exception or because the process was taken out between <code>onStartCommandand</code> and <code>stopService</code>. Android2.0之前，即使没有工作要做，系统也会在内存中挂起许多服务占用资源，这会在<code>stopService</code>由于异常或者进程在<code>onStartCommand</code>和<code>stopService</code>之间被清除而未被调用时发生。Android 2.0 introduced a solution so that we can indicate to the system, if there are no pending intents, that it shouldn’t bother restarting the service. This is OK because whoever started the service to do the work will call it again, such as the alarm manager.This is done by returning the nonsticky flag (<code>Service.START_NOT_STICKY</code>) from
<code>onStartCommand</code>.Android 2.0引入了一种新机制，可以通知系统如果没有 pending intents，service不用被重新启动。在<code>onStartCommand</code>方法中返回<code>Service.START_NOT_STICKY</code>可以达到此目的。However, nonsticky is not really that nonsticky. Remember, even if we mark the service as nonsticky, if there are pending intents, Android will bring the service back to life. This setting applies only when there are no pending intents.</li>
<li>The sticky flag (<code>Service.START_STICKY</code>) means that Android should restart the service even if there are no pending intents. When the service is restarted, call <code>onCreate</code> and <code>onStartCommand</code> with a null intent. This will give the service an opportunity, if need be, to call <code>stopSelf</code> if that is appropriate. The implication is that a service that is sticky needs to deal with null intents on restarts.<code>Service.STAT_STICKY</code>标志指示系统即使在没有pending intents时也应该重启service，service重启时，传递null intent以调用<code>onCreate</code>和<code>onStartCommand</code>。</li>
<li><code>SparseArrays</code> map integers to Objects.  Unlike a normal array of Objects,there can be gaps in the indices.  It is intended to be more <strong>memory efficient than</strong> using a <code>HashMap</code> to map Integers to Objects,both because it avoids auto-boxing keys and its data structure doesn't rely on an extra entry object for each mapping.</li>
<li><code>Parcel</code> Container for a message (data and object references) that can be sent through an <code>IBinder</code>. A Parcel can contain both flattened data that will be unflattened on the other side of the IPC (using the various methods here for writing specific types, or the general Parcelable interface), and references to live IBinder objects that will result in the other side receiving a proxy IBinder connected with the original IBinder in the Parcel.Parcel is not a general-purpose serialization mechanism. This class (and the corresponding Parcelable API for placing arbitrary objects into a Parcel) is designed as a high-performance IPC transport. As such, it is not appropriate to place any Parcel data in to persistent storage: changes in the underlying implementation of any of the data in the Parcel can render older data unreadable.Parcel被设计用来做高性能IPC，不适合做序列化。</li>
<li><code>ConnectivityManager</code> Class that answers queries about the state of network connectivity.查询网络连接状态 It also notifies applications when network connectivity changes. Get an instance of this class by calling <code>Context.getSystemService(Context.CONNECTIVITY_SERVICE)</code>.The primary responsibilities of this class are to:<ul>
<li>Monitor network connections (Wi-Fi, GPRS, UMTS, etc.)</li>
<li>Send broadcast intents when network connectivity changes</li>
<li>Attempt to "fail over" to another network when connectivity to a network is lost</li>
<li>Provide an API that allows applications to query the coarse-grained or fine-grained state of the available networks</li>
</ul>
</li>
<li><code>NetworkPolicyManager</code> Manager for creating and modifying network policy rules.</li>
<li><code>NetworkStatsService</code> Collect and persist detailed network statistics, and provide this data to other system services. <code>NetworkStatsSettings</code>Settings that can be changed externally.</li>
<li><code>HandlerThread</code> Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that <code>start()</code> must still be called.</li>
<li><code>RemoteCallbackList</code> Takes care of the grunt work of maintaining a list of remote interfaces, typically for the use of performing callbacks from a Service to its clients. <code>RemoteCallbackList</code>主要用来处理service对client的回调处理。In particular, this:<ul>
<li>Keeps track of a set of registered <code>IInterface</code> callbacks, taking care to identify them through their underlying unique <code>IBinder</code> (by calling <code>IInterface.asBinder()</code>.</li>
<li>Attaches a <code>IBinder.DeathRecipient</code> to each registered interface, so that it can be cleaned out of the list if its process goes away.</li>
<li>Performs locking of the underlying list of interfaces to deal with multithreaded incoming calls, and a thread-safe way to iterate over a snapshot of the list without holding its lock.
To use this class, simply create a single instance along with your service, and call its <code>register(E)</code> and <code>unregister(E)</code> methods as client register and unregister with your service. To call back on to the registered clients, use <code>beginBroadcast()</code>, <code>getBroadcastItem(int)</code>, and <code>finishBroadcast()</code>.If a registered callback's process goes away, this class will take care of automatically removing it from the list. If you want to do additional work in this situation, you can create a subclass that implements the <code>onCallbackDied(E)</code> method.要使用这个类，创建一个和你的服务相连的实例，client调用<code>register(E)</code>和<code>unregister(E)</code>来register和unregister service。</li>
</ul>
</li>
<li><code>NetworkStats</code> Creates <code>NetworkStats</code> instances by parsing various <code>/proc/</code> files as needed. Collection of active network statistics. Can contain summary details across all interfaces, or details with per-UID granularity. Internally stores data as a large table, closely matching <code>/proc/</code> data format. This structure optimizes for rapid in-memory comparison, but consider using <code>NetworkStatsHistory</code> when persisting.<code>NetworkStats</code>是活动网络数据收集的集合，包含所有活跃的网络接口的统计信息，或者每个UID的细节。在内存中使用一个很大的表作为存储，格式和<code>/proc</code>中数据存储格式很相似。<code>NetworkStats</code>存储结构为内存内的比较进行了优化，如果需要持久化的话，考虑使用<code>NetworkStatsHistory</code>吧。</li>
<li><code>Context.enforceCallingOrSelfPermission(String permission, String message)</code> If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a <code>SecurityException</code>.被授予特殊权限的时候抛出<code>SecurityException</code>异常。</li>
<li><code>NativeDaemonConnector</code> Generic connector class for interfacing with a native daemon which uses the <code>libsysutils</code> FrameworkListener protocol.通用的用来和使用了<code>libsysutils</code> FrameworkListener协议的本地守护进程进行交互的connector class。</li>
<li><code>PendingIntent</code> A description of an <code>Intent</code> and target action to perform with it. Instances of this class are created with <code>getActivity(Context, int, Intent, int)</code>, <code>getActivities(Context, int, Intent[], int)</code>, <code>getBroadcast(Context, int, Intent, int)</code>, and <code>getService(Context, int, Intent, int)</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.返回的对象可以交给其他应用程序，这样其他应用程序可以以你的身份之后执行在<code>PendingIntent</code>中描述的操作。By giving a <code>PendingIntent</code> to another application, you are granting it the right to perform the operation you have specified as if the other application was yourself (with the same permissions and identity). As such, you should be careful about how you build the <code>PendingIntent</code>: almost always, for example, the base Intent you supply should have the component name explicitly set to one of your own components, to ensure it is ultimately sent there and nowhere else.将<code>PendingIntent</code>传递给其他对象意味着给其他应用程序授权，因此应该在构建<code>PendingIntent</code>时加倍小心，应该显示设置要传递的component name。A <code>PendingIntent</code> itself is simply a reference to a token maintained by the system describing the original data used to retrieve it. This means that, even if its owning application's process is killed, the <code>PendingIntent</code> itself will remain usable from other processes that have been given it. If the creating application later re-retrieves the same kind of <code>PendingIntent</code> (same operation, same Intent action, data, categories, and components, and same flags), it will receive a <code>PendingIntent</code> representing the same token if that is still valid, and can thus call cancel() to remove it.<code>PendingIntent</code>是一个引用。Because of this behavior, it is important to know when two Intents are considered to be the same for purposes of retrieving a PendingIntent. A common mistake people make is to create multiple PendingIntent objects with Intents that only vary in their "extra" contents, expecting to get a different PendingIntent each time. This does not happen. The parts of the Intent that are used for matching are the same ones defined by Intent.filterEquals. If you use two Intent objects that are equivalent as per Intent.filterEquals, then you will get the same PendingIntent for both of them.</li>
<li><code>IntentFilter</code> Structured description of <code>Intent</code> values to be matched. An <code>IntentFilter</code> can match against <strong>actions</strong>, <strong>categories</strong>, and <strong>data (either via its type, scheme, and/or path)</strong> in an Intent. It also includes a "priority" value which is used to order multiple matching filters.<code>IntentFilter</code> objects are often created in XML as part of a package's <code>AndroidManifest.xml</code> file, using <code>intent-filter</code> tags.There are three <code>Intent</code> characteristics you can filter on: the action, data, and categories. For each of these characteristics you can provide multiple possible matching values (via <code>addAction(String)</code>, <code>addDataType(String)</code>, <code>addDataScheme(String)</code>, <code>addDataSchemeSpecificPart(String, int)</code>, <code>addDataAuthority(String, String)</code>, <code>addDataPath(String, int)</code>, and <code>addCategory(String)</code>, respectively). For actions, the field will not be tested if no values have been given (treating it as a wildcard); if no data characteristics are specified, however, then the filter will only match intents that contain no data.</li>
<li><code>DropBoxManager</code> Enqueues chunks of data (from various sources -- application crashes, kernel log records, etc.). The queue is size bounded and will drop old data if the enqueued data exceeds the maximum size. You can think of this as a persistent, system-wide, blob-oriented "logcat".You can obtain an instance of this class by calling <code>getSystemService(String)</code> with <code>DROPBOX_SERVICE</code>.<code>DropBoxManager</code> entries are not sent anywhere directly, but other system services and debugging tools may scan and upload entries for processing.<code>DropBoxManager</code>将不同来源的数据入列。队列有大小，超出队列大小时，将会把旧数据丢弃，可以把<code>DropBoxManager</code>当做一个持久化的，系统范围的，二进制的<code>logcat</code>。可以从服务中得到它。</li>
<li><code>NetworkStatsRecorder</code> Logic to record deltas between periodic <code>NetworkStats</code> snapshots into <code>NetworkStatsHistory</code> that belong to <code>networkStatsCollection</code>.Keeps pending changes in memory until they pass a specific threshold, in  bytes. Uses <code>FileRotator</code> for persistence logic.Not inherently thread safe.</li>
<li><code>NetworkStatsCollection</code> Collection of <code>NetworkStatsHistory</code>, stored based on combined key of <code>NetworkIdentitySet</code>, UID, set, and tag. Knows how to persist itself.</li>
<li><code>AtomicFile</code> Helper class for performing atomic operations on a file by creating a backup file until a write has successfully completed. If you need this on older versions of the platform you can use <code>AtomicFile</code> in the v4 support library.Atomic file guarantees file integrity by ensuring that a file has been completely written and sync'd to disk before removing its backup. As long as the backup file exists, the original file is considered to be invalid (left over from a previous attempt to write the file).通过创建一个文件的备份来保证在文件上的操作是原子性的，保证文件被写入并同步到了磁盘，这些操作没有完成不会删除备份文件，如果备份文件存在，原来的文件就是不合法的，因为也许上一次尝试写入文件没有完成就离开了。Atomic file does not confer any file locking semantics. Do not use this class when the file may be accessed or modified concurrently by multiple threads or processes. The caller is responsible for ensuring appropriate mutual exclusion invariants whenever it accesses the file.<code>AtomicFile</code>不提供锁机制，当这个文件可能被并发访问或修改时不要使用<code>AtomicFile</code>。</li>
<li>Android系统原生自带的<code>style.xml</code>在目录<code>framework/base/core/res/res/values/styles.xml</code></li>
<li><code>NetworkTemplate</code> Template definition used to generically match <code>NetworkIdentity</code>,usually when collecting statistics.<code>NetworkTemplate</code>主要用来收集统计信息。</li>
<li><code>Loader</code> An abstract class that performs asynchronous loading of data. While Loaders are active they should monitor the source of their data and deliver new results when the contents change.</li>
<li><code>ContentResolver</code> <code>public final void registerContentObserver (Uri uri, boolean notifyForDescendents, ContentObserver observer)</code> Register an observer class that gets callbacks when data identified by a given content URI changes.注册一个observer类，当给定的URI所指向的内容发生变化时，用来回调。</li>
</ul>
    </div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2012-2014 Solarex.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
   </body>
</html>